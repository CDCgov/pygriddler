{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"griddler","text":"<p>Griddles are the main functionality of griddle. Read about the griddle schema to get started.</p>"},{"location":"#using-griddler-from-the-command-line","title":"Using griddler from the command line","text":"<p>Griddler can also be used on the command line to read an input YAML (or JSON) and write output JSON:</p> <pre><code>python -m griddler my_griddle.yaml &gt; my_parameter_sets.json\n</code></pre> <p>Use the <code>--help</code> flag for more details.</p>"},{"location":"#using-griddle-in-other-python-projects","title":"Using griddle in other python projects","text":"<p>You can generate a griddle directly in Python:</p> <pre><code>import yaml\n\nimport griddler\n\nwith open(\"my_griddle.yaml\") as f:\n    raw_griddle = yaml.safe_load(f)\n\ngriddle = griddler.Griddle(raw_griddle)\nparameter_sets = griddle.parse()\n</code></pre> <p>See the API reference for specifics on griddler's internals.</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#griddler.Experiment","title":"<code>Experiment</code>","text":"<p>An Experiment is set of Specs, supporting union and product operations.</p> Source code in <code>griddler/core.py</code> <pre><code>class Experiment:\n    \"\"\"\n    An Experiment is set of Specs, supporting union and product operations.\n    \"\"\"\n\n    def __init__(self, specs: Iterable[dict]):\n        self.specs = list(specs)\n\n        for spec in self.specs:\n            assert isinstance(spec, dict)\n\n    def __str__(self) -&gt; str:\n        spec_str = \", \".join(str(spec) for spec in self.specs)\n        return f\"Experiment([{spec_str}])\"\n\n    def union(self, other: \"Experiment\") -&gt; \"Experiment\":\n        assert isinstance(other, Experiment)\n        return Experiment(self.specs + other.specs)\n\n    def __or__(self, other: \"Experiment\") -&gt; \"Experiment\":\n        return self.union(other)\n\n    def __mul__(self, other: \"Experiment\") -&gt; \"Experiment\":\n        assert isinstance(other, Experiment)\n\n        return Experiment([x | y for x in self.specs for y in other.specs])\n\n    def __iter__(self) -&gt; Iterable[dict]:\n        return iter(self.specs)\n</code></pre>"},{"location":"api/#griddler.parse","title":"<code>parse(griddle)</code>","text":"<p>Parse a griddle into an Experiment.</p> Source code in <code>griddler/__init__.py</code> <pre><code>def parse(griddle: dict) -&gt; Experiment:\n    \"\"\"Parse a griddle into an Experiment.\"\"\"\n    assert isinstance(griddle, dict), \"griddle must be a dictionary\"\n    assert \"schema\" in griddle, \"griddle must have a schema\"\n\n    match griddle[\"schema\"]:\n        case \"v0.1\":\n            return griddler.schemas.v01.parse(griddle)\n        case \"v0.3\":\n            return griddler.schemas.v03.parse(griddle)\n        case \"v0.4\":\n            return griddler.schemas.v04.parse(griddle)\n        case _:\n            raise RuntimeError(f\"Unknown griddle schema: {griddle['schema']}\")\n</code></pre>"},{"location":"core_concepts/","title":"Core concepts","text":"<p>There is no common nomenclature for the problem griddler solves, so we make up our own. There are 2 core concepts in griddler: the Spec and the Experiment.</p> <p>A Spec is a set of parameter name-value pairs. Typically, a Spec corresponds to the variables and other configuration required to specify and run a single simulation. One Spec can be updated by another one, creating a new Spec with values from the updating Spec.</p> <p>An Experiment is a set of Specs. An Experiment might include replicate simulations with different random seeds, simple grids of parameter values (hence, \"griddler\"), or more complex combinations of parameters. Experiments support two operations:</p> <ul> <li>The union of two Experiments, which is just the union of the their constituent Specs, is another Experiment.</li> <li>The product of two Experiments, similar to a Cartesian product, is another Experiment formed by taking each Spec in one Experiment and updating it with each Spec in the other Experiment.</li> </ul> <p>Experiments, combined with unions and products, are sufficient to produce all sorts of simulations!</p>"},{"location":"core_concepts/#implementation","title":"Implementation","text":"<p>In the <code>griddler</code> package, Specs are just dictionaries, which have the <code>update</code> (or <code>|</code>) operation. Experiments are objects of the <code>Experiment</code> class. Each <code>Experiment</code> holds a set of Specs, supports <code>.union()</code> (or <code>|</code>) and <code>.product()</code> (or <code>*</code>).</p> <p>See the API reference for more details.</p>"},{"location":"core_concepts/#theory","title":"Theory","text":""},{"location":"core_concepts/#specs","title":"Specs","text":"<p>Specifically, a Spec is a set of name-value pairs, i.e., two-element sequences. Specs have a single, binary operation update \\(\\uparrow\\) that adds the parameters in the right input to the left input, preferring the right value when the same name is present in both Specs. For two Specs \\(S\\) and \\(T\\),</p> \\[ \\begin{align*} S \\uparrow T = &amp;\\{ (n, v) : (n, v) \\in S \\text{ and } n \\in \\pi(S) \\backslash \\pi(T) \\} \\\\ &amp;\\cup \\{ (n, v) : (n, v) \\in T \\text{ and } n \\notin \\pi(S) \\backslash \\pi(T) \\} \\\\ \\end{align*} \\] <p>where \\(\\pi(\\cdot)\\) is the set of names in a Spec (i.e., the first projection map) and \\(\\backslash\\) is set difference.</p> <p>(The update operation is similar to null coalescence, which prefers the left value.)</p> <p>Specs and the update operation \\(\\uparrow\\) form a monoid because there is an identity element (i.e., the empty set \\(\\varnothing\\)) and the operation is associative. Note that Specs are not commutative: the order of the inputs matters.</p>"},{"location":"core_concepts/#experiments","title":"Experiments","text":"<p>An Experiment is a set of Specs, equipped with two operations: union \\(\\cap\\), which is just the union of the constituent sets of Specs, and product \\(\\otimes\\), analogous to Cartesian product. For two experiments \\(X\\) and \\(Y\\), define \\(X \\otimes Y = \\{S \\uparrow T : S \\in X, T \\in Y\\}\\).</p> <p>Experiments and their two operations form a semiring. Union \\(\\cap\\) is a commutative monoid whose identity element is the empty Experiment \\(\\varnothing\\) (i.e., a set of no Specs at all). Product \\(\\otimes\\) is a non-commutative monoid with identity element \\(\\{ \\varnothing \\}\\) (i.e., an Experiment consisting of a single empty Spec). Note that the union identity \\(\\varnothing\\) is an absorbing element under the product operation: \\(X \\otimes \\varnothing = \\varnothing \\otimes X = \\varnothing\\) for any Experiment \\(X\\).</p>"},{"location":"core_concepts/#conditional-parameters","title":"Conditional parameters","text":"<p>Informally, the \"conditional\" parameters in the v0.3 schema \"filter\" for parts of the Experiment and add new parameters in those situations.</p> <p>Formally, conditional parameters require partitioning an Experiment into two parts. Each conditional parameter Spec \\(P\\) is associated with a subset \\(Z\\) of Specs in the experiment \\(X\\). Adding a conditional parameter means taking the product of \\(P\\) with this subset of \\(X\\), keeping the other subsets of \\(X\\) unchanged:</p> \\[ (Z \\otimes P) \\cup (X \\setminus Z) \\] <p>In the v0.3 schema, the subset \\(Z\\) are those Specs that \"match\" some spec \\(M\\):</p> \\[ z \\in Z \\iff z \\uparrow M = z \\] <p>In other words, \\(Z\\) consists of those Specs that have that same name-value pairs that are in \\(M\\).</p> <p>In principle, the subset \\(Z\\) could be defined by any predicate function, not just \"matching.\"</p>"},{"location":"griddles/","title":"Griddles","text":"<p>For complex Experiments, you might want to write a Python file that manipulates <code>Spec</code> and <code>Experiment</code> objects directly. See the API reference for more details.</p> <p>For simpler Experiments, griddler supports griddles. A griddle is a dictionary, usually read in from a human-written file like a YAML or JSON, that specifies the schema and then whatever is needed to uniquely specify the Experiment. (Technically, a griddle is a Python dictionary, but we might also loosely refer to the YAML or JSON file as a \"griddle.\")</p> <p>Every griddle must have the keyword <code>\"schema\"</code> and an associated string value that specifies how the griddle should be parsed into an Experiment. Beyond that, each schema can specify different requirements for the griddle format.</p> <p>The currently-supported griddle schemas are:</p> <ul> <li>v0.4</li> </ul>"},{"location":"griddles/#schemas","title":"Schemas","text":""},{"location":"griddles/#v04","title":"v0.4","text":"<p>Schema <code>v0.4</code> adheres as close as possible to the underlying griddler logic while not actually requiring any Python. The trivial example is:</p> <pre><code>schema: v0.4\nexperiment: []\n</code></pre> <p>This returns an empty Experiment (i.e., containing zero Specs). The minimal example, of a single, fixed parameter is:</p> <pre><code>schema: v0.4\nexperiment: [{ R0: 1.0 }]\n</code></pre> <p>This produces an Experiment with a single Spec. Serialized as JSON:</p> <pre><code>[{ \"R0\": 1.0 }]\n</code></pre> <p>An example of the product might be:</p> <pre><code>schema: v0.4\nexperiment:\n  product:\n    - [{ R0: 1.5 }, { R0: 2.0 }]\n    - [{ gamma: 0.3 }, { gamma: 0.4 }]\n</code></pre> <p>which produces 4 Specs, with all combinations of input varying parameters:</p> <pre><code>[\n  { \"R0\": 1.5, \"gamma\": 0.3 },\n  { \"R0\": 1.5, \"gamma\": 0.4 },\n  { \"R0\": 2.0, \"gamma\": 0.3 },\n  { \"R0\": 2.0, \"gamma\": 0.4 }\n]\n</code></pre> <p>Unions become useful when combining Experiments that vary different parameters. For example, an Experiment might consist of some simulations where a simulated quantity follows the normal distribution and other simulations where it follows the gamma distribution. For the normal distribution simulations, we might want to grid over values of the mean and standard deviation, while in the gamma distribution simulations, we want to grid over shape and scale parameters:</p> <pre><code>schema: v0.4\nexperiment:\n  product:\n    - [{ R0: 1.5 }]\n    - union:\n        - product:\n            - [{ distribution: normal }]\n            - [{ mean: 0.5 }, { mean: 1.0 }, { mean: 1.5 }]\n            - [{ sd: 0.5 }, { sd: 1.0 }]\n        - product:\n            - [{ distribution: gamma }]\n            - [{ shape: 0.5 }, { shape: 1.0 }]\n            - [{ scale: 0.5 }, { scale: 1.0 }]\n</code></pre> <p>which produces multiple Specs:</p> <pre><code>[\n  { \"R0\": 1.5, \"distribution\": \"normal\", \"mean\": 0.5, \"sd\": 0.5 },\n  { \"R0\": 1.5, \"distribution\": \"normal\", \"mean\": 0.5, \"sd\": 1.0 },\n  { \"R0\": 1.5, \"distribution\": \"normal\", \"mean\": 1.0, \"sd\": 0.5 },\n  // etc. with further mean/sd combinations\n  { \"R0\": 1.5, \"distribution\": \"gamma\", \"shape\": 0.5, \"scale\": 0.5 }\n  // etc. with further shape/scale combinations\n]\n</code></pre>"},{"location":"griddles/#syntax","title":"Syntax","text":"<p>The <code>v0.4</code> schema has syntax:</p> <pre><code>schema: v0.4\nexperiment: &lt;experiment&gt;\n</code></pre> <p>where the experiment has syntax:</p> <pre><code>&lt;experiment&gt; ::= [{&lt;key&gt;: &lt;value&gt;, ...}, ...]\n                 | {\"union\": [&lt;experiment&gt;, ...]}\n                 | {\"product\": [&lt;experiment&gt;, ...]}\n</code></pre>"},{"location":"griddles/#v03","title":"v0.3","text":"<p>The v0.3 syntax is designed to for simple combinations of fixed and varying parameters.</p>"},{"location":"griddles/#minimal-griddle","title":"Minimal griddle","text":"<p>The minimal functional griddle has a schema and no parameters.</p> <pre><code>schema: v0.3\nparameters: {}\n</code></pre>"},{"location":"griddles/#fixed-parameters","title":"Fixed parameters","text":"<p>A fixed parameter has the same value in all Specs (unless the parameter is conditioned).</p> <pre><code>schema: v0.3\nparameters:\n  NAME:\n    fix: VALUE\n  # note that this could be written in YAML as:\n  # NAME: {fix: VALUE}\n</code></pre> <p>In this and future examples, capitals are used to designate values that would be filled in. In future examples, <code>schema</code> is omitted for brevity.</p> <p>Note that the value of a fixed parameter need not be a scalar. For example, <code>delay_distribution_pmf</code> would appear as the same array in all the parameter sets:</p> <pre><code>parameters:\n  delay_distribution_pmf: { fix: [0.0, 0.1, 0.2, 0.3, 0.2, 0.1, 0.0] }\n</code></pre>"},{"location":"griddles/#varying-parameter","title":"Varying parameter","text":"<p>A varying parameter takes on different values in different Specs. In the absence of conditioning or bundling, all combinations of all varying parameters will appear in the output.</p> <pre><code>parameters:\n  NAME:\n    vary: [VALUE1, VALUE2]\n  # note that this could be written in YAML as:\n  # NAME: {vary: [VALUE1, VALUE2]}\n</code></pre>"},{"location":"griddles/#varying-bundles-of-parameters","title":"Varying bundles of parameters","text":"<p>In a varying bundle of parameters, multiple parameters take on different values in different data sets, but those parameters vary together.</p> <pre><code>parameters:\n  BUNDLE_NAME:\n    vary:\n      NAME1: [NAME1_VALUE1, NAME1_VALUE2] # and so on for NAME1_VALUE3, etc.\n      NAME2: [NAME2_VALUE1, NAME2_VALUE2]\n      # and so on for NAME3, etc.\n</code></pre> <p>In the parameter sets, <code>NAME1</code> will take on the <code>NAME1_VALUE*</code> values, <code>NAME2</code> will take on the <code>NAME2_VALUE*</code> values, and so forth. The <code>*_VALUE1</code> values will always appear together, the <code>*_VALUE2</code> will always appear together, and so forth, so the values lists must all be of equal length. <code>BUNDLE_NAME</code> is a unique identifier for the bundle of parameters <code>NAME1</code>, <code>NAME2</code>, etc. and does not appear in the parameter sets. <code>BUNDLE_NAME</code> cannot be the same as any parameter name.</p> <p>Note that a single varying parameter could be written as:</p> <pre><code>parameters:\n  BUNDLE_NAME:\n    vary:\n      NAME: [VALUE1, VALUE2]\n</code></pre> <p>with the caveat that <code>BUNDLE_NAME</code> and <code>NAME</code> cannot be the same.</p>"},{"location":"griddles/#conditioned-parameters","title":"Conditioned parameters","text":"<p>A conditioned parameter will only be present in a parameter set when some one or more other parameters are present and take on some particular values. A the value associated with the <code>if</code> keyword is a condition that evaluates to true or false.</p> <p>For now, the only supported conditions are:</p> <ol> <li><code>{}</code>, which is always true, and</li> <li>a test for equality of a single parameter to a single value: <code>{equals: {COND_NAME: COND_VALUE}}</code>.</li> </ol> <pre><code>parameters:\n  FIXED_NAME:\n    fix: VALUE\n    if: true\n\n  VARYING_NAME:\n    vary:\n      VARYING_PARAM_NAME: [VALUE1, VALUE2]\n    if: { equals: { COND_NAME: COND_VALUE } }\n</code></pre> <p>Conditioned parameters are evaluated after unconditioned parameters, but the order of their evaluation is not guaranteed. Thus, a graph of dependent <code>if</code> statements is not supported.</p>"},{"location":"griddles/#comments","title":"Comments","text":"<p>Any content in a <code>comment</code> field is ignored. This is not important in YAML files, which have native comments, but can be useful in a human-written JSON. Comments are only available in canonical forms.</p> <pre><code>parameters:\n  FIXED_NAME:\n    comment: THIS TEXT IS IGNORED\n    fix: VALUE\n  VARYING_PARAM_NAME:\n    comment: THIS TEXT IS IGNORED\n    vary: [VARY_VALUE1, VARY_VALUE2]\n</code></pre>"},{"location":"griddles/#examples","title":"Examples","text":""},{"location":"griddles/#only-fixed-parameters","title":"Only fixed parameters","text":"<pre><code>parameters:\n  R0: { fix: 3.0 }\n  infectious_period: { fix: 1.0 }\n  p_infected_initial: { fix: 0.001 }\n</code></pre> <p>This produces only a single parameter set:</p> <pre><code>[{ \"R0\": 3.0, \"infectious_period\": 1.0, \"p_infected_initial\": 0.001 }]\n</code></pre>"},{"location":"griddles/#2-varying-parameters-and-1-fixed","title":"2 varying parameters and 1 fixed","text":"<pre><code>parameters:\n  - R0: { vary: [2.0, 3.0] }\n  - infectious_period: { vary: [0.5, 2.0] }\n  - p_infected_initial: { fix: 0.001 }\n</code></pre> <p>This produces 4 parameter sets:</p> <pre><code>[\n  { \"R0\": 2.0, \"infectious_period\": 0.5, \"p_infected_initial\": 0.001 },\n  { \"R0\": 2.0, \"infectious_period\": 2.0, \"p_infected_initial\": 0.001 },\n  { \"R0\": 3.0, \"infectious_period\": 0.5, \"p_infected_initial\": 0.001 },\n  { \"R0\": 3.0, \"infectious_period\": 2.0, \"p_infected_initial\": 0.001 }\n]\n</code></pre> <p>Note that the ordering of the outputs is not guaranteed.</p>"},{"location":"griddles/#varying-parameter-bundles","title":"Varying parameter bundles","text":"<pre><code>parameters:\n  scenario:\n    vary:\n      R0: [2.0, 4.0],\n      p_infected_initial: [0.01, 0.0001]\n  infectious_period: {vary: [0.5, 2.0]}\n</code></pre> <p>\\(R_0\\) and \\(p_{I0}\\) vary together, and the infectious period \\(1/\\gamma\\) varies separately, producing 4 parameter sets:</p> <ol> <li>\\(R_0=2\\), \\(p_{I0}=10^{-2}\\), \\(1/\\gamma=0.5\\)</li> <li>\\(R_0=2\\), \\(p_{I0}=10^{-2}\\), \\(1/\\gamma=2\\)</li> <li>\\(R_0=4\\), \\(p_{I0}=10^{-4}\\), \\(1/\\gamma=0.5\\)</li> <li>\\(R_0=4\\), \\(p_{I0}=10^{-4}\\), \\(1/\\gamma=2\\)</li> </ol>"},{"location":"griddles/#conditioned-varying-parameter","title":"Conditioned varying parameter","text":"<p>Vary over two states, matching with their capitals, and then also vary over beach towns in the coastal state:</p> <pre><code>parameters:\n  state_and_capital:\n    vary:\n      state: [Virginia, North Dakota]\n      capital: [Richmond, Pierre]\n  beach_town:\n    if: { equals: { state: Virginia } }\n    vary: [Virginia Beach, Chincoteague, Colonial Beach]\n</code></pre> <p>This produces 4 parameter sets. Note that <code>\"beach_town\"</code> is only present when <code>\"state\"</code> is <code>\"Virginia\"</code>:</p> <pre><code>[\n  {\n    \"state\": \"Virginia\",\n    \"capital\": \"Richmond\",\n    \"beach_town\": \"Virginia Beach\"\n  },\n  { \"state\": \"Virginia\", \"capital\": \"Richmond\", \"beach_town\": \"Chincoteague\" },\n  {\n    \"state\": \"Virginia\",\n    \"capital\": \"Richmond\",\n    \"beach_town\": \"Colonial Beach\"\n  },\n  { \"state\": \"North Dakota\", \"capital\": \"Pierre\" }\n]\n</code></pre>"},{"location":"griddles/#v02","title":"v0.2","text":"<p>The v0.2 syntax is described in historical docs. It is not currently supported.</p>"},{"location":"griddles/#v01","title":"v0.1","text":"<p>There are grid parameters. Each grid parameter is a name and a list of values. The Specs are first formed by first taking the product over those parameters.</p> <p>Then, any baseline parameters are added. These are essentially grid parameters, but with only a single value.</p> <p>Finally, nested parameters are added. Each nest is itself a Spec. Every gridded Spec should match exactly zero or one of the nest Specs. A gridded Spec and a nest match Spec if the they have at least one parameter name-value pair in common.</p> <p>For example:</p> <pre><code>schema: v0.1\n\nbaseline_parameters:\n  R0: 1.0\n\ngrid_parameters:\n  scenario: [baseline, pessimistic, optimistic]\n  gamma: [1.0, 2.0]\n\nnested_parameters:\n  - scenario: pessimistic\n    R0: 1.5\n  - scenario: optimistic\n    R0: 0.75\n</code></pre> <p>will produce 6 Specs, one for each combination of <code>scenario</code> and <code>gamma</code>, with a value for <code>R0</code> that is either drawn from the baseline (for the baseline scenario) or from the nests.</p>"}]}